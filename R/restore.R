
#' Restore a Project
#'
#' Restore a project's dependencies from a lockfile, as previously generated by
#' [snapshot()].
#'
#' @param lockfile The lockfile to be used for restoration of the associated
#'   project. When `NULL`, the most recently generated lockfile for this project
#'   is used.
#'
#' @param actions The restore actions to take. By default, all actions are
#'   taken, thereby synchronizing the state of the project library with that of
#'   the lockfile. See **Actions** for more details.
#'
#' @section Actions:
#'
#' `renv` classifies the different actions that will be taken during restore
#' into five fundamental types:
#'
#' \tabular{ll}{
#'
#' \code{install} \tab
#'   Install a package recorded in the lockfile,
#'   but not currently installed in the project library. \cr
#'
#' \code{remove} \tab
#'   Remove a package installed in the project library,
#'   but not currently recorded in the lockfile. \cr
#'
#' \code{upgrade} \tab
#'   Upgrade a package by replacing the (older) version of the package
#'   available in the project library with a newer version as defined
#'   in the lockfile. \cr
#'
#' \code{downgrade} \tab
#'   Downgrade a package by replacing the (newer) version of the package
#'   available in the project library with an older version as defined
#'   in the lockfile. \cr
#'
#' \code{crossgrade} \tab
#'   Install a package whose lockfile record differs from the inferred
#'   record associated with the currently-installed version. This could
#'   happen if, for example, the source of a particular package was changed
#'   (e.g. a package originally installed from GitHub was later installed
#'   from CRAN). \cr
#'
#' }
#'
#' This can be useful if you want to perform only non-destructive changes during
#' restore -- for example, you can invoke `renv::restore(actions = "install")`
#' to avoid modifying or removing packages that have already been installed into
#' your project's private library.
#'
#' @inheritParams renv-params
#'
#' @family reproducibility
#'
#' @export
restore <- function(project  = NULL,
                    lockfile = NULL,
                    actions  = c("install", "remove", "upgrade", "downgrade", "crossgrade"),
                    confirm  = interactive())
{
  project <- project %||% renv_project()

  # resolve the lockfile
  lockfile <- case(
    is.null(lockfile)      ~ renv_lockfile_load(project),
    is.character(lockfile) ~ renv_lockfile_read(lockfile),
    lockfile
  )

  on.exit(renv_python_restore(project), add = TRUE)

  # detect changes in R packages in the lockfile
  current <- snapshot(file = NULL)
  diff <- renv_lockfile_diff_packages(current, lockfile)

  # only keep requested actions
  diff <- diff[diff %in% actions]

  # don't take any actions with ignored packages
  diff <- diff[setdiff(names(diff), settings$ignored.packages())]

  if (!length(diff)) {
    vmessagef("* The project is already synchronized with the lockfile.")
    return(invisible(diff))
  }

  if (confirm || renv_verbose())
    renv_restore_report_actions(diff, current, lockfile)

  if (confirm && !proceed()) {
    message("Operation aborted.")
    return(invisible(diff))
  }

  # ensure that the private project library is available and active
  oldlibpaths <- .libPaths()
  newlibpaths <- c(renv_paths_library(project), oldlibpaths)
  lapply(newlibpaths, ensure_directory)
  .libPaths(newlibpaths)
  on.exit(.libPaths(oldlibpaths), add = TRUE)

  # perform the restore
  status <- renv_restore_run_actions(diff, current, lockfile)

  # check to see if the lockfile is now up-to-date; if it's not,
  # then the restore might've repaired the dependency tree and
  # we should snapshot to capture the new changes
  renv_restore_postamble(project, lockfile, confirm)

  invisible(status)
}

renv_restore_postamble <- function(project, lockfile, confirm) {
  actions <- renv_lockfile_diff_packages(lockfile, snapshot(file = NULL))
  if (empty(actions))
    return(NULL)

  msg <- stack()
  msg$push("The dependency tree was repaired during package restoration.")
  if (confirm)
    msg$push("You will be prompted to snapshot the newly-installed packages.")
  else
    msg$push("The lockfile will be updated with the newly-installed packages.")

  writeLines(as.character(msg$data()))
  snapshot(project = project, confirm = confirm)
}

renv_restore_run_actions <- function(actions, current, lockfile) {

  records <- lockfile$R$Packages
  renv_restore_begin(records, names(actions))
  on.exit(renv_restore_end(), add = TRUE)

  # first, handle package removals
  removes <- actions[actions == "remove"]
  enumerate(removes, function(package, action) {
    renv_restore_remove(package, current)
  })

  # next, handle installs
  installs <- actions[actions != "remove"]
  packages <- names(installs)
  records <- lockfile$R$Packages

  records <- renv_restore_retrieve(packages, records)
  renv_restore_install(records)

}

renv_restore_state <- function() {
  renv_global_get("restore.state")
}

renv_restore_begin <- function(records = NULL, packages = NULL, recursive = TRUE) {

  envir <- env(

    # the package records used for restore, providing information
    # on the packages to be installed (their version, source, etc)
    records = records,

    # the set of packages to be installed in this restore session
    packages = packages,

    # should package dependencies be crawled recursively? this is useful if
    # the records list is incomplete and needs to be built as packages are
    # downloaded
    recursive = recursive,

    # packages which we have attempted to retrieve during restore
    retrieved = stack(),
    retrieved.env = new.env(parent = emptyenv()),

    # a collection of the requirements imposed on dependent packages
    # as they are discovered
    requirements = new.env(parent = emptyenv())

  )

  renv_global_set("restore.state", envir)

}

renv_restore_end <- function() {
  renv_global_clear("restore.state")
}

renv_restore_report_actions <- function(actions, current, lockfile) {

  if ("install" %in% actions) {
    msg <- "The following package(s) will be installed:"
    renv_pretty_print(msg, lockfile, actions, "install")
  }

  if ("remove" %in% actions) {
    msg <- "The following package(s) will be removed:"
    renv_pretty_print(msg, current, actions, "remove")
  }

  if ("upgrade" %in% actions) {
    msg <- "The following package(s) will be upgraded:"
    renv_pretty_print_pair(msg, current, lockfile, actions, "upgrade")
  }

  if ("downgrade" %in% actions) {
    msg <- "The following package(s) will be downgraded:"
    renv_pretty_print_pair(msg, current, lockfile, actions, "downgrade")
  }

  if ("crossgrade" %in% actions) {
    msg <- "The following package(s) will be modified:"
    renv_pretty_print_pair(msg, current, lockfile, actions, "crossgrade")
  }

}

renv_restore_remove <- function(package, lockfile) {
  record <- lockfile$R$Package[[package]]
  messagef("Removing %s [%s] ...", package, record$Version)
  remove.packages(package, renv_paths_library(record$Library) %||% NULL)
  message("\tOK (removed from library)")
  TRUE
}
